#!/usr/bin/env python3
"""
Facility Service Filters Generator

This script automatically generates individual filter files for each facility type
based on the CSV checklist configuration. It parses the CSV file and creates
JavaScript filter files that define which data elements should be shown for each
facility type and section.

Usage:
    python src/config/generateFilters.py

Input:
    - src/config/checklist for facilities2.0.csv

Output:
    - Individual .js files for each facility type in src/config/
    - Updated facilityServiceFilters.js with proper imports
    - Auto-generated facilityServiceDepartments.js with department mappings
    - Generation summary report

Author: Auto-generated by Augment Agent
Date: 2025-09-02
Updated: 2025-09-21 (Added facilityServiceDepartments.js generation)
"""

import csv
import json
import re
from datetime import datetime
from pathlib import Path

class FacilityFilterGenerator:
    def __init__(self, csv_path="checklist-final.csv"):
        self.csv_path = csv_path
        self.facility_types = []
        self.sections = []
        self.questions_data = []
        self.config_dir = Path("src/config")

    def parse_csv(self):
        """Parse the CSV file and extract facility types, sections, and questions"""
        print(f"Parsing CSV file: {self.csv_path}")

        # Try different encodings to handle the CSV file
        encodings = ['utf-8', 'utf-8-sig', 'latin-1', 'cp1252']
        lines = None

        for encoding in encodings:
            try:
                with open(self.csv_path, 'r', encoding=encoding) as file:
                    reader = csv.reader(file)
                    lines = list(reader)
                print(f"[OK] Successfully read CSV with {encoding} encoding")
                break
            except UnicodeDecodeError:
                print(f"[ERROR] Failed to read with {encoding} encoding")
                continue

        if lines is None:
            raise ValueError("Could not read CSV file with any supported encoding")

        if len(lines) < 2:
            raise ValueError("CSV file must have at least 2 rows (headers and facility types)")

        # Extract facility types from row 1 (skip first empty column)
        # Keep exact spacing (e.g., "Nursing  Home") to match CSV master exactly
        # Apply name standardization (e.g., Physiotheraphy -> Physiotherapy)
        raw_types = [ft.strip() for ft in lines[0][1:] if ft.strip()]
        
        name_standardization = {
            'Physiotheraphy': 'Physiotherapy',
            'Nursing Home': 'Nursing  Home', # Ensure double space internally if single space in CSV
        }
        
        self.facility_types = [name_standardization.get(ft, ft) for ft in raw_types]
        print(f"Found {len(self.facility_types)} facility types: {self.facility_types}")

        # Parse sections and questions
        current_section = "GENERAL"  # Default section if none found yet

        # Start from row 2 (index 1): row0 = headers of facility types, row1+ = sections/questions
        for i, row in enumerate(lines[1:], start=2):
            if not row or not row[0].strip():
                continue

            first_column = row[0].strip()
            # Clean bullet points, dots, dashes and other prefixes
            # BUT keep trailing -- for detection
            clean_text = re.sub(r'^[\.\-\s]+', '', first_column)
            
            # Determine applicability per facility type on this row
            applicability = []
            for j, _ in enumerate(self.facility_types):
                cell_value = row[j + 1].strip() if j + 1 < len(row) else ''
                applicability.append(cell_value == '?')
            has_any_applicability = any(applicability)

            # Detect section headers
            # A row is a section header IF:
            # 1. It matches strong section header patterns (regardless of '?' markers in CSV)
            # 2. OR It is ALL CAPS with length > 3 (regardless of '?' markers)
            # This allows sections like "DENTAL" to be recognized even if they have applicability markers
            
            clean_text_upper = clean_text.upper()
            is_strong_header = (
                (clean_text_upper.startswith('SECTION ') and not clean_text.strip().endswith('--')) or 
                (clean_text_upper.startswith('FACILITY-') and not clean_text.strip().endswith('--')) or
                (clean_text_upper.startswith('CUSTOMER SATISFACTION') and not clean_text.strip().endswith('--')) or
                (clean_text_upper.startswith('LIASON WITH PRIMARY HEALTH CARE') and not clean_text.strip().endswith('--')) or
                (clean_text_upper.startswith('TOILET FACILITIES') and not clean_text.strip().endswith('--')) or
                (clean_text.isupper() and len(clean_text) > 5 and not clean_text.strip().endswith('?') and not clean_text.strip().endswith('--'))
            )
            
            # Recognize ALL CAPS text as section headers regardless of ? markers
            is_weak_header = (
                (clean_text.isupper() and len(clean_text) > 3 and not clean_text.strip().endswith('--'))
            )

            is_section_header = (
                (is_strong_header or is_weak_header) and 
                (clean_text and not clean_text[0].isdigit())
            )

            if is_section_header:
                # Normalize: Uppercase, remove spaces around hyphens, and strip trailing --/symbols
                current_section = re.sub(r'\s*-\s*', '-', clean_text.upper())
                current_section = re.sub(r'--\s*$', '', current_section).strip()
                # Remove common ending punctuation if it was used as a marker
                current_section = re.sub(r'[?:\.;]+$', '', current_section).strip()
                
                if current_section not in self.sections:
                    self.sections.append(current_section)
                    print(f"Found section: {current_section}")
            elif current_section:
                # Treat as a question if either:
                # - The text ends with '?', or
                # - At least one facility column marks applicability with '?'
                if clean_text.endswith('?') or has_any_applicability:
                    self.questions_data.append({
                        'section': current_section,
                        'question': clean_text,
                        'applicability': applicability,
                        'row_number': i
                    })

        print(f"Found {len(self.sections)} sections")
        print(f"Found {len(self.questions_data)} questions")

        return True

    def normalize_section_name(self, section_name):
        """Normalize section names for consistency"""
        # Section names are already partially normalized in parse_csv
        # Strip trailing dashes and whitespace just in case
        return re.sub(r'--\s*$', '', section_name).strip()

    def generate_facility_filter(self, facility_index, facility_type):
        """Generate filter configuration for a specific facility type"""
        print(f"Generating filter for: {facility_type}")

        facility_config = {}

        for section in self.sections:
            normalized_section = self.normalize_section_name(section)

            # Get all questions that apply to this facility in this section
            applicable_questions = []

            for question_data in self.questions_data:
                if (question_data['section'] == section and
                    facility_index < len(question_data['applicability']) and
                    question_data['applicability'][facility_index]):
                    applicable_questions.append(question_data['question'])

            if applicable_questions:
                facility_config[normalized_section] = {
                    "showOnly": applicable_questions
                }
                print(f"  {normalized_section}: {len(applicable_questions)} questions")

        return facility_config

    def sanitize_filename(self, facility_type):
        """Convert facility type to valid filename"""
        # Remove special characters and convert to lowercase
        filename = facility_type.lower()
        filename = filename.replace(' ', '').replace('(', '').replace(')', '')
        filename = filename.replace('-', '').replace('&', 'and').replace('/', '')
        filename = filename.replace(',', '').replace(':', '').replace(';', '')
        return filename + '.js'

    def generate_js_file_content(self, facility_type, config):
        """Generate the JavaScript file content for a facility filter"""
        sanitized_name = facility_type.replace(' ', '').replace('(', '').replace(')', '').replace('-', '').replace('/', '').replace(',', '').replace(':', '').replace(';', '').replace('&', 'and')

        content = f'''/**
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * Generated from: {self.csv_path}
 * Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
 * Facility Type: {facility_type}
 *
 * To regenerate this file, run: python src/config/generateFilters.py
 */

const {sanitized_name} = {{
'''

        for section_name, section_config in config.items():
            content += f'    "{section_name}": {{\n'
            content += f'        "showOnly": [\n'

            for question in section_config["showOnly"]:
                # Sanitize: collapse actual newlines, remove CRs, and escape backslashes/quotes
                sanitized = question.replace('\r\n', ' ').replace('\n', ' ').replace('\r', ' ').strip()
                sanitized = sanitized.replace('\\', '\\\\').replace('"', '\\"')
                content += f'            "{sanitized}",\n'

            content += f'        ]\n'
            content += f'    }},\n'

        content += f'''
}};

export default {sanitized_name};
'''

        return content

    def write_facility_filter_file(self, facility_type, config):
        """Write the filter configuration to a JavaScript file"""
        filename = self.sanitize_filename(facility_type)
        filepath = self.config_dir / filename

        content = self.generate_js_file_content(facility_type, config)

        with open(filepath, 'w', encoding='utf-8') as file:
            file.write(content)

        print(f"[DONE] Generated: {filepath}")
        return filepath

    def generate_main_filters_file(self):
        """Generate the main facilityServiceFilters.js file with all imports"""
        imports = []
        mappings = []

        for facility_type in self.facility_types:
            sanitized_name = facility_type.replace(' ', '').replace('(', '').replace(')', '').replace('-', '').replace('/', '').replace(',', '').replace(':', '').replace(';', '').replace('&', 'and')
            filename = self.sanitize_filename(facility_type).replace('.js', '')

            # Escape quotes for JS strings - use double quotes as they are safer for these strings
            escaped_type = facility_type.replace('"', '\\"')

            imports.append(f"import {sanitized_name} from './{filename}.js';")
            mappings.append(f'    "{escaped_type}": {sanitized_name},')
            mappings.append(f'    "Service {escaped_type}": {sanitized_name},')

        # Use standard string for the header and imports
        header = f'''/**
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * Generated from: {self.csv_path}
 * Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
 *
 * This file imports all individual clinic filter files and combines them
 * To regenerate this file, run: python src/config/generateFilters.py
 */

'''
        
        # Construct the content part by part to avoid f-string escaping issues
        content = header
        content += "\n".join(imports) + "\n\n"
        content += "const facilityServiceFilters = {\n"
        content += "\n".join(mappings) + "\n"
        content += "};\n\n"
        
        # Append the JS function as a raw string
        content += r'''
export function shouldShowDataElementForService(dataElementName, selectedService, sectionName = null) {
    if (!selectedService || !facilityServiceFilters[selectedService]) {
        return true; // Show all if no service selected or service not found
    }

    // SPECIAL EXCEPTION: Hospital facility type should show ALL data elements without filtering
    // This allows hospitals to access all sections and questions from DHIS2
    if (selectedService === 'Hospital' || selectedService === 'Service Hospital') {
        return true;
    }

    const serviceFilters = facilityServiceFilters[selectedService];

    // Helper to normalize strings for comparison (handles apostrophes, case, and whitespace)
    const normalize = (str) => {
        if (!str) return '';
        // Strip leading non-alphanumeric symbols like bullets
        return str.replace(/^[^a-zA-Z0-9(]+/, "").replace(/[']/g, "").toLowerCase().trim();
    };

    const normalizedDataElementName = normalize(dataElementName);

    // Helper to find a section key case-insensitively
    const findSectionKey = (filters, name) => {
        if (!name) return null;
        const normalizedName = normalize(name);
        // First try exact match
        if (filters[name]) return name;
        // Then try case-insensitive match
        return Object.keys(filters).find(key => normalize(key) === normalizedName);
    };

    // If a section name is provided, only check within that specific section
    if (sectionName) {
        // Try to find the section key (handling case mismatches)
        const matchedSectionKey = findSectionKey(serviceFilters, sectionName);
        
        if (matchedSectionKey) {
            const section = serviceFilters[matchedSectionKey];
            if (section && section.showOnly) {
                return section.showOnly.some(item => 
                    item === dataElementName || normalize(item) === normalizedDataElementName
                );
            }
        }
        
        // Let's try one more fallback: check if the section name is a substring of a key or vice versa
        const looseSectionKey = Object.keys(serviceFilters).find(key => 
            key.toLowerCase().includes(sectionName.toLowerCase()) || 
            sectionName.toLowerCase().includes(key.toLowerCase())
        );
        
        if (looseSectionKey) {
             const section = serviceFilters[looseSectionKey];
             if (section && section.showOnly) {
                const foundInSection = section.showOnly.some(item => 
                    item === dataElementName || normalize(item) === normalizedDataElementName
                );
                if (foundInSection) return true;
            }
        }

        // FALLBACK: If not found in the specific section provided by DHIS2, 
        // check if it's allowed ANYWHERE for this service.
        // This handles cases where DHIS2 and CSV have different section mappings.
        for (const sectionKey in serviceFilters) {
            const section = serviceFilters[sectionKey];
            if (section && section.showOnly) {
                const foundAnywhere = section.showOnly.some(item => 
                    item === dataElementName || normalize(item) === normalizedDataElementName
                );
                if (foundAnywhere) return true;
            }
        }

        // If not found anywhere in filters, don't show the element
        return false;
    }

    // If no section name provided, check across all sections (legacy behavior)
    for (const section in serviceFilters) {
        if (serviceFilters[section].showOnly) {
            if (serviceFilters[section].showOnly.some(item => 
                item === dataElementName || normalize(item) === normalizedDataElementName
            )) {
                return true;
            }
        }
    }

    return false; // Hide if not in showOnly lists
}

export default facilityServiceFilters;
'''

        main_file_path = self.config_dir / "facilityServiceFilters.js"
        with open(main_file_path, 'w', encoding='utf-8') as file:
            file.write(content)

        print(f"[DONE] Generated main file: {main_file_path}")
        return main_file_path

    def generate_facility_service_departments_file(self):
        """Generate the facilityServiceDepartments.js file based on actual sections from CSV"""
        print("Generating facilityServiceDepartments.js...")

        # Get all unique sections (departments) from the CSV
        all_departments = []
        for section in self.sections:
            normalized_section = self.normalize_section_name(section)
            if normalized_section not in all_departments:
                all_departments.append(normalized_section)

        # Preserve CSV order (don't sort alphabetically)
        # all_departments.sort()

        # Build specialization to department mapping
        specialization_mapping = {}

        for i, facility_type in enumerate(self.facility_types):
            # Get departments in the order they actually appear with questions for THIS facility
            facility_departments = []
            seen_depts = set()
            
            for question_data in self.questions_data:
                if (i < len(question_data['applicability']) and 
                    question_data['applicability'][i]):
                    
                    normalized_section = self.normalize_section_name(question_data['section'])
                    if normalized_section not in seen_depts:
                        facility_departments.append(normalized_section)
                        seen_depts.add(normalized_section)

            specialization_mapping[facility_type] = facility_departments

            print(f"  {facility_type}: {len(facility_departments)} departments")

        # Generate the JavaScript content
        content = f'''/**
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * Generated from: {self.csv_path}
 * Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
 *
 * This file defines facility service departments based on actual sections
 * found in the CSV checklist configuration.
 * To regenerate this file, run: python src/config/generateFilters.py
 */

// All available facility service departments (sections from CSV)
export const ALL_FACILITY_DEPARTMENTS = [
'''

        # Add all departments
        for dept in all_departments:
            escaped_dept = dept.replace('"', '\\"')
            content += f'  "{escaped_dept}",\n'

        content += '''];

// Mapping of specializations to their available departments
export const SPECIALIZATION_DEPARTMENT_MAPPING = {
'''

        # Add specialization mappings
        for facility_type, departments in specialization_mapping.items():
            escaped_type = facility_type.replace('"', '\\"')
            content += f'  "{escaped_type}": [\n'
            for dept in departments:
                escaped_dept = dept.replace('"', '\\"')
                content += f'    "{escaped_dept}",\n'
            content += f"  ],\n\n"

        content += '''};

/**
 * Get departments available for a specific specialization
 * @param {string} specialization - The facility specialization
 * @returns {Array<string>} Array of department names
 */
export function getDepartmentsForSpecialization(specialization) {
  if (!specialization || !SPECIALIZATION_DEPARTMENT_MAPPING[specialization]) {
    return ALL_FACILITY_DEPARTMENTS;
  }
  return SPECIALIZATION_DEPARTMENT_MAPPING[specialization];
}

/**
 * Get statistics about departments for a specialization
 * @param {string} specialization - The facility specialization
 * @returns {Object} Statistics object with total and available counts
 */
export function getDepartmentStats(specialization) {
  const available = getDepartmentsForSpecialization(specialization);
  return {
    total: ALL_FACILITY_DEPARTMENTS.length,
    available: available.length,
    specialization: specialization
  };
}

export default {
  ALL_FACILITY_DEPARTMENTS,
  SPECIALIZATION_DEPARTMENT_MAPPING,
  getDepartmentsForSpecialization,
  getDepartmentStats
};
'''

        # Write the file
        departments_file_path = self.config_dir / "facilityServiceDepartments.js"
        with open(departments_file_path, 'w', encoding='utf-8') as file:
            file.write(content)

        print(f"[DONE] Generated: {departments_file_path}")
        print(f"Total departments: {len(all_departments)}")
        print(f"Specializations: {len(specialization_mapping)}")

        return departments_file_path

    def generate_summary_report(self):
        """Generate a summary report of the generation process"""
        summary = {
            "generated_on": datetime.now().isoformat(),
            "source_file": self.csv_path,
            "facility_types": self.facility_types,
            "sections": [self.normalize_section_name(s) for s in self.sections],
            "statistics": {
                "total_facility_types": len(self.facility_types),
                "total_sections": len(self.sections),
                "total_questions": len(self.questions_data)
            }
        }

        # Add per-facility statistics
        summary["facility_statistics"] = {}
        for i, facility_type in enumerate(self.facility_types):
            applicable_count = sum(1 for q in self.questions_data
                                 if i < len(q['applicability']) and q['applicability'][i])
            summary["facility_statistics"][facility_type] = {
                "applicable_questions": applicable_count,
                "coverage_percentage": round((applicable_count / len(self.questions_data)) * 100, 1)
            }

        report_path = self.config_dir / "generation_report.json"
        with open(report_path, 'w', encoding='utf-8') as file:
            json.dump(summary, file, indent=2)

        print(f"Generated report: {report_path}")
        return summary

    def run(self):
        """Main execution method"""
        print("Starting Facility Filter Generation...")
        print("-" * 60)

        try:
            # Parse the CSV file
            self.parse_csv()

            print("\nGenerating individual filter files...")
            generated_files = []

            # Generate filter file for each facility type
            for i, facility_type in enumerate(self.facility_types):
                config = self.generate_facility_filter(i, facility_type)
                if config:  # Only generate if there are applicable questions
                    filepath = self.write_facility_filter_file(facility_type, config)
                    generated_files.append(filepath)
                else:
                    print(f"[WARN] No applicable questions found for: {facility_type}")

            # Generate main filters file
            print(f"\nGenerating main facilityServiceFilters.js...")
            self.generate_main_filters_file()

            # Generate facility service departments file
            print(f"\nGenerating facilityServiceDepartments.js...")
            self.generate_facility_service_departments_file()

            # Generate summary report
            print(f"\nGenerating summary report...")
            self.generate_summary_report()

            print("-" * 60)
            print("Generation Complete!")
            print(f" Generated {len(generated_files)} facility filter files")
            print(f" Generated main filter file: facilityServiceFilters.js")
            print(f" Generated departments file: facilityServiceDepartments.js")
            print(f"Total entries: {len(self.questions_data)}")
            print(f"Facility types: {len(self.facility_types)}")
            print(f"Sections: {len(self.sections)}")

            return True

        except Exception as e:
            print(f"Error during generation: {str(e)}")
            return False

if __name__ == "__main__":
    generator = FacilityFilterGenerator()
    success = generator.run()

    if success:
        print("\n Filter generation completed successfully!")
        print(" You can now use the generated filter files in your application.")
    else:
        print("\n Filter generation failed. Please check the error messages above.")
        exit(1)