#!/usr/bin/env python3
"""
Facility Service Filters Generator

This script automatically generates individual filter files for each facility type
based on the CSV checklist configuration. It parses the CSV file and creates
JavaScript filter files that define which data elements should be shown for each
facility type and section.

Usage:
    python src/config/generateFilters.py

Input:
    - src/config/checklist for facilities2.0.csv

Output:
    - Individual .js files for each facility type in src/config/
    - Updated facilityServiceFilters.js with proper imports
    - Auto-generated facilityServiceDepartments.js with department mappings
    - Generation summary report

Author: Auto-generated by Augment Agent
Date: 2025-09-02
Updated: 2025-09-21 (Added facilityServiceDepartments.js generation)
"""

import csv
import json
from datetime import datetime
from pathlib import Path

class FacilityFilterGenerator:
    def __init__(self, csv_path="src/config/checklist for facilities2.0.csv"):
        self.csv_path = csv_path
        self.facility_types = []
        self.sections = []
        self.questions_data = []
        self.config_dir = Path("src/config")

    def parse_csv(self):
        """Parse the CSV file and extract facility types, sections, and questions"""
        print(f"üìÑ Parsing CSV file: {self.csv_path}")

        # Try different encodings to handle the CSV file
        encodings = ['utf-8', 'utf-8-sig', 'latin-1', 'cp1252']
        lines = None

        for encoding in encodings:
            try:
                with open(self.csv_path, 'r', encoding=encoding) as file:
                    reader = csv.reader(file)
                    lines = list(reader)
                print(f"‚úÖ Successfully read CSV with {encoding} encoding")
                break
            except UnicodeDecodeError:
                print(f"‚ùå Failed to read with {encoding} encoding")
                continue

        if lines is None:
            raise ValueError("Could not read CSV file with any supported encoding")

        if len(lines) < 2:
            raise ValueError("CSV file must have at least 2 rows (headers and facility types)")

        # Extract facility types from row 1 (skip first empty column)
        self.facility_types = [ft.strip() for ft in lines[0][1:] if ft.strip()]
        print(f"üè• Found {len(self.facility_types)} facility types: {self.facility_types}")

        # Parse sections and questions
        current_section = None

        # Start from row 2 (index 1): row0 = headers of facility types, row1+ = sections/questions
        for i, row in enumerate(lines[1:], start=2):
            if not row or not row[0].strip():
                continue

            first_column = row[0].strip()

            # Detect section headers - fully capitalized names (no lowercase letters)
            if (first_column and
                first_column.isupper() and
                len(first_column) > 3 and
                not first_column.endswith('?')):

                current_section = first_column
                if current_section not in self.sections:
                    self.sections.append(current_section)
                    print(f"üìã Found section: {current_section}")

            # Detect questions (lines with ? that are not section headers)
            elif current_section:
                # Determine applicability per facility type on this row
                applicability = []
                for j, _ in enumerate(self.facility_types):
                    cell_value = row[j + 1].strip() if j + 1 < len(row) else ''
                    applicability.append(cell_value == '?')

                # Treat as a question if either:
                # - The text ends with '?', or
                # - At least one facility column marks applicability with '?'
                has_any_applicability = any(applicability)
                if first_column.endswith('?') or has_any_applicability:
                    self.questions_data.append({
                        'section': current_section,
                        'question': first_column,
                        'applicability': applicability,
                        'row_number': i
                    })

        print(f"üìã Found {len(self.sections)} sections")
        print(f"‚ùì Found {len(self.questions_data)} questions")

        return True

    def normalize_section_name(self, section_name):
        """Normalize section names for consistency"""
        # Section names are already properly formatted in the CSV (fully capitalized)
        # Just return as-is since they're already normalized
        return section_name.strip()

    def generate_facility_filter(self, facility_index, facility_type):
        """Generate filter configuration for a specific facility type"""
        print(f"üîß Generating filter for: {facility_type}")

        facility_config = {}

        for section in self.sections:
            normalized_section = self.normalize_section_name(section)

            # Get all questions that apply to this facility in this section
            applicable_questions = []

            for question_data in self.questions_data:
                if (question_data['section'] == section and
                    facility_index < len(question_data['applicability']) and
                    question_data['applicability'][facility_index]):
                    applicable_questions.append(question_data['question'])

            if applicable_questions:
                facility_config[normalized_section] = {
                    "showOnly": applicable_questions
                }
                print(f"  üìù {normalized_section}: {len(applicable_questions)} questions")

        return facility_config

    def sanitize_filename(self, facility_type):
        """Convert facility type to valid filename"""
        # Remove special characters and convert to lowercase
        filename = facility_type.lower()
        filename = filename.replace(' ', '').replace('(', '').replace(')', '')
        filename = filename.replace('-', '').replace('&', 'and')
        return filename + '.js'

    def generate_js_file_content(self, facility_type, config):
        """Generate the JavaScript file content for a facility filter"""
        sanitized_name = facility_type.replace(' ', '').replace('(', '').replace(')', '').replace('-', '')

        content = f'''/**
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * Generated from: checklist for facilities2.0.csv
 * Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
 * Facility Type: {facility_type}
 *
 * To regenerate this file, run: python src/config/generateFilters.py
 */

const {sanitized_name} = {{
'''

        for section_name, section_config in config.items():
            content += f'    "{section_name}": {{\n'
            content += f'        "showOnly": [\n'

            for question in section_config["showOnly"]:
                # Sanitize: collapse newlines, remove CRs, and escape backslashes/quotes
                sanitized = question.replace('\r\n', ' ').replace('\n', ' ').replace('\r', ' ').strip()
                sanitized = sanitized.replace('\\', '\\\\').replace('"', '\\"')
                content += f'            "{sanitized}",\n'

            content += f'        ]\n'
            content += f'    }},\n'

        content += f'''
}};

export default {sanitized_name};
'''

        return content

    def write_facility_filter_file(self, facility_type, config):
        """Write the filter configuration to a JavaScript file"""
        filename = self.sanitize_filename(facility_type)
        filepath = self.config_dir / filename

        content = self.generate_js_file_content(facility_type, config)

        with open(filepath, 'w', encoding='utf-8') as file:
            file.write(content)

        print(f"‚úÖ Generated: {filepath}")
        return filepath

    def generate_main_filters_file(self):
        """Generate the main facilityServiceFilters.js file with all imports"""
        imports = []
        mappings = []

        for facility_type in self.facility_types:
            sanitized_name = facility_type.replace(' ', '').replace('(', '').replace(')', '').replace('-', '')
            filename = self.sanitize_filename(facility_type).replace('.js', '')

            imports.append(f"import {sanitized_name} from './{filename}.js';")
            mappings.append(f"    '{facility_type}': {sanitized_name},")
            mappings.append(f"    'Service {facility_type}': {sanitized_name},")

        content = f'''/**
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * Generated from: checklist for facilities2.0.csv
 * Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
 *
 * This file imports all individual clinic filter files and combines them
 * To regenerate this file, run: python src/config/generateFilters.py
 */

{chr(10).join(imports)}

const facilityServiceFilters = {{
{chr(10).join(mappings)}
}};

export function shouldShowDataElementForService(dataElementName, selectedService) {{
    if (!selectedService || !facilityServiceFilters[selectedService]) {{
        return true; // Show all if no service selected or service not found
    }}

    const serviceFilters = facilityServiceFilters[selectedService];

    // Check if the data element should be shown for this service
    for (const section in serviceFilters) {{
        if (serviceFilters[section].showOnly && serviceFilters[section].showOnly.includes(dataElementName)) {{
            return true;
        }}
    }}

    return false; // Hide if not in showOnly lists
}}

export default facilityServiceFilters;
'''

        main_file_path = self.config_dir / "facilityServiceFilters.js"
        with open(main_file_path, 'w', encoding='utf-8') as file:
            file.write(content)

        print(f"‚úÖ Generated main file: {main_file_path}")
        return main_file_path

    def generate_facility_service_departments_file(self):
        """Generate the facilityServiceDepartments.js file based on actual sections from CSV"""
        print("üè¢ Generating facilityServiceDepartments.js...")

        # Get all unique sections (departments) from the CSV
        all_departments = []
        for section in self.sections:
            normalized_section = self.normalize_section_name(section)
            if normalized_section not in all_departments:
                all_departments.append(normalized_section)

        # Sort departments alphabetically for consistency
        all_departments.sort()

        # Build specialization to department mapping
        specialization_mapping = {}

        for i, facility_type in enumerate(self.facility_types):
            # Get sections that have questions for this facility type
            facility_departments = []

            for section in self.sections:
                normalized_section = self.normalize_section_name(section)

                # Check if this section has any questions for this facility
                has_questions = any(
                    question_data['section'] == section and
                    i < len(question_data['applicability']) and
                    question_data['applicability'][i]
                    for question_data in self.questions_data
                )

                if has_questions:
                    facility_departments.append(normalized_section)

            # Sort departments for this facility
            facility_departments.sort()
            specialization_mapping[facility_type] = facility_departments

            print(f"  üè• {facility_type}: {len(facility_departments)} departments")

        # Generate the JavaScript content
        content = f'''/**
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * Generated from: checklist for facilities2.0.csv
 * Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
 *
 * This file defines facility service departments based on actual sections
 * found in the CSV checklist configuration.
 * To regenerate this file, run: python src/config/generateFilters.py
 */

// All available facility service departments (sections from CSV)
export const ALL_FACILITY_DEPARTMENTS = [
'''

        # Add all departments
        for dept in all_departments:
            content += f"  '{dept}',\n"

        content += '''];

// Mapping of specializations to their available departments
export const SPECIALIZATION_DEPARTMENT_MAPPING = {
'''

        # Add specialization mappings
        for facility_type, departments in specialization_mapping.items():
            content += f"  '{facility_type}': [\n"
            for dept in departments:
                content += f"    '{dept}',\n"
            content += f"  ],\n\n"

        content += '''};

/**
 * Get departments available for a specific specialization
 * @param {string} specialization - The facility specialization
 * @returns {Array<string>} Array of department names
 */
export function getDepartmentsForSpecialization(specialization) {
  if (!specialization || !SPECIALIZATION_DEPARTMENT_MAPPING[specialization]) {
    return ALL_FACILITY_DEPARTMENTS;
  }
  return SPECIALIZATION_DEPARTMENT_MAPPING[specialization];
}

/**
 * Get statistics about departments for a specialization
 * @param {string} specialization - The facility specialization
 * @returns {Object} Statistics object with total and available counts
 */
export function getDepartmentStats(specialization) {
  const available = getDepartmentsForSpecialization(specialization);
  return {
    total: ALL_FACILITY_DEPARTMENTS.length,
    available: available.length,
    specialization: specialization
  };
}

export default {
  ALL_FACILITY_DEPARTMENTS,
  SPECIALIZATION_DEPARTMENT_MAPPING,
  getDepartmentsForSpecialization,
  getDepartmentStats
};
'''

        # Write the file
        departments_file_path = self.config_dir / "facilityServiceDepartments.js"
        with open(departments_file_path, 'w', encoding='utf-8') as file:
            file.write(content)

        print(f"‚úÖ Generated: {departments_file_path}")
        print(f"üìä Total departments: {len(all_departments)}")
        print(f"üè• Specializations: {len(specialization_mapping)}")

        return departments_file_path

    def generate_summary_report(self):
        """Generate a summary report of the generation process"""
        summary = {
            "generated_on": datetime.now().isoformat(),
            "source_file": self.csv_path,
            "facility_types": self.facility_types,
            "sections": [self.normalize_section_name(s) for s in self.sections],
            "statistics": {
                "total_facility_types": len(self.facility_types),
                "total_sections": len(self.sections),
                "total_questions": len(self.questions_data)
            }
        }

        # Add per-facility statistics
        summary["facility_statistics"] = {}
        for i, facility_type in enumerate(self.facility_types):
            applicable_count = sum(1 for q in self.questions_data
                                 if i < len(q['applicability']) and q['applicability'][i])
            summary["facility_statistics"][facility_type] = {
                "applicable_questions": applicable_count,
                "coverage_percentage": round((applicable_count / len(self.questions_data)) * 100, 1)
            }

        report_path = self.config_dir / "generation_report.json"
        with open(report_path, 'w', encoding='utf-8') as file:
            json.dump(summary, file, indent=2)

        print(f"üìä Generated report: {report_path}")
        return summary

    def run(self):
        """Main execution method"""
        print("üöÄ Starting Facility Filter Generation...")
        print("=" * 60)

        try:
            # Parse the CSV file
            self.parse_csv()

            print("\nüîß Generating individual filter files...")
            generated_files = []

            # Generate filter file for each facility type
            for i, facility_type in enumerate(self.facility_types):
                config = self.generate_facility_filter(i, facility_type)
                if config:  # Only generate if there are applicable questions
                    filepath = self.write_facility_filter_file(facility_type, config)
                    generated_files.append(filepath)
                else:
                    print(f"‚ö†Ô∏è  No applicable questions found for: {facility_type}")

            # Generate main filters file
            print(f"\nüîß Generating main facilityServiceFilters.js...")
            self.generate_main_filters_file()

            # Generate facility service departments file
            print(f"\nüè¢ Generating facilityServiceDepartments.js...")
            self.generate_facility_service_departments_file()

            # Generate summary report
            print(f"\nüìä Generating summary report...")
            self.generate_summary_report()

            print("\n" + "=" * 60)
            print("‚úÖ Generation Complete!")
            print(f"üìÅ Generated {len(generated_files)} facility filter files")
            print(f"üìÅ Generated main filter file: facilityServiceFilters.js")
            print(f"üìÅ Generated departments file: facilityServiceDepartments.js")
            print(f"üìä Total questions processed: {len(self.questions_data)}")
            print(f"üè• Facility types: {len(self.facility_types)}")
            print(f"üìã Sections: {len(self.sections)}")

            return True

        except Exception as e:
            print(f"‚ùå Error during generation: {str(e)}")
            return False

if __name__ == "__main__":
    generator = FacilityFilterGenerator()
    success = generator.run()

    if success:
        print("\nüéâ Filter generation completed successfully!")
        print("üí° You can now use the generated filter files in your application.")
    else:
        print("\nüí• Filter generation failed. Please check the error messages above.")
        exit(1)