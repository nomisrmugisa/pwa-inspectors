#!/usr/bin/env python3
"""
Facility Service Filters Generator

This script automatically generates individual filter files for each facility type
based on the CSV checklist configuration. It parses the CSV file and creates
JavaScript filter files that define which data elements should be shown for each
facility type and section.

Usage:
    python src/config/generateFilters.py

Input:
    - src/config/checklist for facilities2.0.csv

Output:
    - Individual .js files for each facility type in src/config/
    - Updated facilityServiceFilters.js with proper imports
    - Generation summary report

Author: Auto-generated by Augment Agent
Date: 2025-09-02
"""

import csv
import json
from datetime import datetime
from pathlib import Path

class FacilityFilterGenerator:
    def __init__(self, csv_path="src/config/checklist for facilities2.0.csv"):
        self.csv_path = csv_path
        self.facility_types = []
        self.sections = []
        self.questions_data = []
        self.config_dir = Path("src/config")

    def parse_csv(self):
        """Parse the CSV file and extract facility types, sections, and questions"""
        print(f"üìÑ Parsing CSV file: {self.csv_path}")

        # Try different encodings to handle the CSV file
        encodings = ['utf-8', 'utf-8-sig', 'latin-1', 'cp1252']
        lines = None

        for encoding in encodings:
            try:
                with open(self.csv_path, 'r', encoding=encoding) as file:
                    reader = csv.reader(file)
                    lines = list(reader)
                print(f"‚úÖ Successfully read CSV with {encoding} encoding")
                break
            except UnicodeDecodeError:
                print(f"‚ùå Failed to read with {encoding} encoding")
                continue

        if lines is None:
            raise ValueError("Could not read CSV file with any supported encoding")

        if len(lines) < 2:
            raise ValueError("CSV file must have at least 2 rows (headers and facility types)")

        # Extract facility types from row 1 (skip first empty column)
        self.facility_types = [ft.strip() for ft in lines[0][1:] if ft.strip()]
        print(f"üè• Found {len(self.facility_types)} facility types: {self.facility_types}")

        # Parse sections and questions
        current_section = None

        for i, row in enumerate(lines[2:], start=3):  # Start from row 3 (skip headers and numbers)
            if not row or not row[0].strip():
                continue

            first_column = row[0].strip()

            # Detect section headers - fully capitalized names (no lowercase letters)
            if (first_column and
                first_column.isupper() and
                len(first_column) > 3 and
                not first_column.endswith('?')):

                current_section = first_column
                if current_section not in self.sections:
                    self.sections.append(current_section)
                    print(f"üìã Found section: {current_section}")

            # Detect questions (lines with ? that are not section headers)
            elif first_column.endswith('?') and current_section:
                # Get applicability for each facility type
                applicability = []
                for j, _ in enumerate(self.facility_types):
                    # Check if this question applies to this facility (marked with ?)
                    cell_value = row[j + 1].strip() if j + 1 < len(row) else ''
                    applies = cell_value == '?'
                    applicability.append(applies)

                self.questions_data.append({
                    'section': current_section,
                    'question': first_column,
                    'applicability': applicability,
                    'row_number': i
                })

        print(f"üìã Found {len(self.sections)} sections")
        print(f"‚ùì Found {len(self.questions_data)} questions")

        return True

    def normalize_section_name(self, section_name):
        """Normalize section names for consistency"""
        # Section names are already properly formatted in the CSV (fully capitalized)
        # Just return as-is since they're already normalized
        return section_name.strip()

    def generate_facility_filter(self, facility_index, facility_type):
        """Generate filter configuration for a specific facility type"""
        print(f"üîß Generating filter for: {facility_type}")

        facility_config = {}

        for section in self.sections:
            normalized_section = self.normalize_section_name(section)

            # Get all questions that apply to this facility in this section
            applicable_questions = []

            for question_data in self.questions_data:
                if (question_data['section'] == section and
                    facility_index < len(question_data['applicability']) and
                    question_data['applicability'][facility_index]):
                    applicable_questions.append(question_data['question'])

            if applicable_questions:
                facility_config[normalized_section] = {
                    "showOnly": applicable_questions
                }
                print(f"  üìù {normalized_section}: {len(applicable_questions)} questions")

        return facility_config

    def sanitize_filename(self, facility_type):
        """Convert facility type to valid filename"""
        # Remove special characters and convert to lowercase
        filename = facility_type.lower()
        filename = filename.replace(' ', '').replace('(', '').replace(')', '')
        filename = filename.replace('-', '').replace('&', 'and')
        return filename + '.js'

    def generate_js_file_content(self, facility_type, config):
        """Generate the JavaScript file content for a facility filter"""
        sanitized_name = facility_type.replace(' ', '').replace('(', '').replace(')', '').replace('-', '')

        content = f'''/**
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * Generated from: checklist for facilities2.0.csv
 * Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
 * Facility Type: {facility_type}
 *
 * To regenerate this file, run: python src/config/generateFilters.py
 */

const {sanitized_name} = {{
'''

        for section_name, section_config in config.items():
            content += f'    "{section_name}": {{\n'
            content += f'        "showOnly": [\n'

            for question in section_config["showOnly"]:
                # Escape quotes in questions
                escaped_question = question.replace('"', '\\"')
                content += f'            "{escaped_question}",\n'

            content += f'        ]\n'
            content += f'    }},\n'

        content += f'''
}};

export default {sanitized_name};
'''

        return content

    def write_facility_filter_file(self, facility_type, config):
        """Write the filter configuration to a JavaScript file"""
        filename = self.sanitize_filename(facility_type)
        filepath = self.config_dir / filename

        content = self.generate_js_file_content(facility_type, config)

        with open(filepath, 'w', encoding='utf-8') as file:
            file.write(content)

        print(f"‚úÖ Generated: {filepath}")
        return filepath

    def generate_main_filters_file(self):
        """Generate the main facilityServiceFilters.js file with all imports"""
        imports = []
        mappings = []

        for facility_type in self.facility_types:
            sanitized_name = facility_type.replace(' ', '').replace('(', '').replace(')', '').replace('-', '')
            filename = self.sanitize_filename(facility_type).replace('.js', '')

            imports.append(f"import {sanitized_name} from './{filename}.js';")
            mappings.append(f"    '{facility_type}': {sanitized_name},")

        content = f'''/**
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * Generated from: checklist for facilities2.0.csv
 * Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
 *
 * This file imports all individual clinic filter files and combines them
 * To regenerate this file, run: python src/config/generateFilters.py
 */

{chr(10).join(imports)}

const facilityServiceFilters = {{
{chr(10).join(mappings)}
}};

export function shouldShowDataElementForService(dataElementName, selectedService) {{
    if (!selectedService || !facilityServiceFilters[selectedService]) {{
        return true; // Show all if no service selected or service not found
    }}

    const serviceFilters = facilityServiceFilters[selectedService];

    // Check if the data element should be shown for this service
    for (const section in serviceFilters) {{
        if (serviceFilters[section].showOnly && serviceFilters[section].showOnly.includes(dataElementName)) {{
            return true;
        }}
    }}

    return false; // Hide if not in showOnly lists
}}

export default facilityServiceFilters;
'''

        main_file_path = self.config_dir / "facilityServiceFilters.js"
        with open(main_file_path, 'w', encoding='utf-8') as file:
            file.write(content)

        print(f"‚úÖ Generated main file: {main_file_path}")
        return main_file_path

    def generate_summary_report(self):
        """Generate a summary report of the generation process"""
        summary = {
            "generated_on": datetime.now().isoformat(),
            "source_file": self.csv_path,
            "facility_types": self.facility_types,
            "sections": [self.normalize_section_name(s) for s in self.sections],
            "statistics": {
                "total_facility_types": len(self.facility_types),
                "total_sections": len(self.sections),
                "total_questions": len(self.questions_data)
            }
        }

        # Add per-facility statistics
        summary["facility_statistics"] = {}
        for i, facility_type in enumerate(self.facility_types):
            applicable_count = sum(1 for q in self.questions_data
                                 if i < len(q['applicability']) and q['applicability'][i])
            summary["facility_statistics"][facility_type] = {
                "applicable_questions": applicable_count,
                "coverage_percentage": round((applicable_count / len(self.questions_data)) * 100, 1)
            }

        report_path = self.config_dir / "generation_report.json"
        with open(report_path, 'w', encoding='utf-8') as file:
            json.dump(summary, file, indent=2)

        print(f"üìä Generated report: {report_path}")
        return summary

    def run(self):
        """Main execution method"""
        print("üöÄ Starting Facility Filter Generation...")
        print("=" * 60)

        try:
            # Parse the CSV file
            self.parse_csv()

            print("\nüîß Generating individual filter files...")
            generated_files = []

            # Generate filter file for each facility type
            for i, facility_type in enumerate(self.facility_types):
                config = self.generate_facility_filter(i, facility_type)
                if config:  # Only generate if there are applicable questions
                    filepath = self.write_facility_filter_file(facility_type, config)
                    generated_files.append(filepath)
                else:
                    print(f"‚ö†Ô∏è  No applicable questions found for: {facility_type}")

            # Generate main filters file
            print(f"\nüîß Generating main facilityServiceFilters.js...")
            self.generate_main_filters_file()

            # Generate summary report
            print(f"\nüìä Generating summary report...")
            self.generate_summary_report()

            print("\n" + "=" * 60)
            print("‚úÖ Generation Complete!")
            print(f"üìÅ Generated {len(generated_files)} facility filter files")
            print(f"üìÅ Generated main filter file: facilityServiceFilters.js")
            print(f"üìä Total questions processed: {len(self.questions_data)}")
            print(f"üè• Facility types: {len(self.facility_types)}")
            print(f"üìã Sections: {len(self.sections)}")

            return True

        except Exception as e:
            print(f"‚ùå Error during generation: {str(e)}")
            return False

if __name__ == "__main__":
    generator = FacilityFilterGenerator()
    success = generator.run()

    if success:
        print("\nüéâ Filter generation completed successfully!")
        print("üí° You can now use the generated filter files in your application.")
    else:
        print("\nüí• Filter generation failed. Please check the error messages above.")
        exit(1)