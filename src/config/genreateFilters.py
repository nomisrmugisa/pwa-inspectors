#!/usr/bin/env python3
"""
Facility Service Filters Generator

This script automatically generates individual filter files for each facility type
based on the CSV checklist configuration. It parses the CSV file and creates
JavaScript filter files that define which data elements should be shown for each
facility type and section.

Usage:
    python src/config/generateFilters.py

Input:
    - src/config/checklist-final.csv

Output:
    - Individual .js files for each facility type in src/config/
    - Updated facilityServiceFilters.js with proper imports
    - Auto-generated facilityServiceDepartments.js with department mappings
    - Generation summary report

Author: Auto-generated by Augment Agent
Date: 2025-09-02
Updated: 2025-09-21 (Added facilityServiceDepartments.js generation)
"""

import csv
import json
from datetime import datetime
from pathlib import Path


def normalize_text(text):
    """
    Normalize corrupted special characters from CSV encoding issues.

    This handles common encoding problems when CSV files are created in Windows
    with Windows-1252 encoding but read as UTF-8 or Latin-1, causing character corruption.

    Mappings:
        √¥ ‚Üí " (Left double quote)
        √∂ ‚Üí " (Right double quote)
        √≤ ‚Üí ' (Left single quote)
        √≥ ‚Üí ' (Right single quote)
        ‚Äì ‚Üí - (En dash)
        ‚Äî ‚Üí - (Em dash)
        ‚Ä¶ ‚Üí ... (Ellipsis)
        ÔøΩ ‚Üí (removed) (Unicode replacement character)

    Windows-1252 control characters (when read as Latin-1):
        \x91 ‚Üí ' (Left single quote)
        \x92 ‚Üí ' (Right single quote / apostrophe)
        \x93 ‚Üí " (Left double quote)
        \x94 ‚Üí " (Right double quote)
        \x96 ‚Üí - (En dash)
        \x97 ‚Üí - (Em dash)
        \x85 ‚Üí ... (Ellipsis)

    Unicode curly quotes:
        ' ‚Üí ' (Right single quote U+2019)
        ' ‚Üí ' (Left single quote U+2018)
        " ‚Üí " (Left double quote U+201C)
        " ‚Üí " (Right double quote U+201D)
    """
    if not text:
        return text

    replacements = {
        # Corrupted UTF-8 characters (Windows-1252 misread as UTF-8)
        '√¥': '"',   # Left double quote
        '√∂': '"',   # Right double quote
        '√≤': "'",   # Left single quote
        '√≥': "'",   # Right single quote
        '‚Äì': '-',   # En dash
        '‚Äî': '-',   # Em dash
        '‚Ä¶': '...', # Ellipsis
        'ÔøΩ': '',    # Unicode replacement character (remove)

        # Windows-1252 control characters (when read as Latin-1)
        '\x91': "'",   # Left single quote
        '\x92': "'",   # Right single quote / apostrophe
        '\x93': '"',   # Left double quote
        '\x94': '"',   # Right double quote
        '\x96': '-',   # En dash
        '\x97': '-',   # Em dash
        '\x85': '...', # Ellipsis

        # Unicode curly quotes (normalize to straight quotes)
        ''': "'",   # Right single quote U+2019
        ''': "'",   # Left single quote U+2018
        '"': '"',   # Left double quote U+201C
        '"': '"',   # Right double quote U+201D
    }

    for old, new in replacements.items():
        text = text.replace(old, new)

    return text


class FacilityFilterGenerator:
    def __init__(self, csv_path="checklist-final.csv"):
        self.csv_path = csv_path
        self.facility_types = []
        self.sections = []
        self.questions_data = []
        self.config_dir = Path("src/config")

    def parse_csv(self):
        """Parse the CSV file and extract facility types, sections, and questions"""
        print(f"üìÑ Parsing CSV file: {self.csv_path}")

        # Try different encodings to handle the CSV file
        encodings = ['utf-8', 'utf-8-sig', 'latin-1', 'cp1252']
        lines = None

        for encoding in encodings:
            try:
                with open(self.csv_path, 'r', encoding=encoding) as file:
                    reader = csv.reader(file)
                    lines = list(reader)
                print(f"‚úÖ Successfully read CSV with {encoding} encoding")
                break
            except UnicodeDecodeError:
                print(f"‚ùå Failed to read with {encoding} encoding")
                continue

        if lines is None:
            raise ValueError("Could not read CSV file with any supported encoding")

        if len(lines) < 2:
            raise ValueError("CSV file must have at least 2 rows (headers and facility types)")

        # Extract facility types from row 1 (skip first empty column)
        # Apply normalization to handle corrupted special characters
        self.facility_types = [normalize_text(ft.strip()) for ft in lines[0][1:] if ft.strip()]
        print(f"üè• Found {len(self.facility_types)} facility types: {self.facility_types}")

        # Parse sections and questions
        current_section = None

        # Start from row 2 (index 1): row0 = headers of facility types, row1+ = sections/questions
        for i, row in enumerate(lines[1:], start=2):
            if not row or not row[0].strip():
                continue

            # Normalize text to handle corrupted special characters from CSV encoding issues
            first_column = normalize_text(row[0].strip())

            # Detect section headers - fully capitalized names (no lowercase letters)
            # Rules:
            # 1. Must be fully uppercase (punctuation allowed)
            # 2. Must be longer than 3 characters
            # 3. Must NOT start with a number (no number prefixes like "21.16 ELISA", "1.0 GOVERNANCE")
            # 4. Must NOT end with "--" (excludes subsection headers like "ELISA--", "Rapid HIV Testing--")
            if (first_column and
                first_column.isupper() and
                len(first_column) > 3 and
                not first_column[0].isdigit() and
                not first_column.endswith('--')):

                current_section = first_column
                if current_section not in self.sections:
                    self.sections.append(current_section)
                    print(f"üìã Found section: {current_section}")

            # Detect questions (lines with ? that are not section headers)
            elif current_section:
                # Determine applicability per facility type on this row
                applicability = []
                for j, _ in enumerate(self.facility_types):
                    cell_value = row[j + 1].strip() if j + 1 < len(row) else ''
                    applicability.append(cell_value == '?')

                # Treat as a question if either:
                # - The text ends with '?', or
                # - At least one facility column marks applicability with '?'
                has_any_applicability = any(applicability)
                if first_column.endswith('?') or has_any_applicability:
                    self.questions_data.append({
                        'section': current_section,
                        'question': first_column,
                        'applicability': applicability,
                        'row_number': i
                    })

        print(f"üìã Found {len(self.sections)} sections")
        print(f"‚ùì Found {len(self.questions_data)} questions")

        return True

    def normalize_section_name(self, section_name):
        """Normalize section names for consistency"""
        # Section names are already properly formatted in the CSV (fully capitalized)
        # Just return as-is since they're already normalized
        return section_name.strip()

    def generate_facility_filter(self, facility_index, facility_type):
        """Generate filter configuration for a specific facility type"""
        print(f"üîß Generating filter for: {facility_type}")

        facility_config = {}

        # Use Hospital-specific order for Hospital, otherwise use self.sections
        if facility_type == 'Hospital':
            sections_to_process = [
                "FACILITY GOVERNANCE AND MANAGEMENT",
                "HUMAN RESOURCE MANAGEMENT",
                "ADMINISTRATIVE SERVICES",
                "FACILITY ENVIRONMENT",
                "CUSTOMER CARE, RIGHTS AND SATISFACTION",
                "SAFETY AND WASTE MANAGEMENT",
                "INFECTION PREVENTION AND CONTROL",
                "FACILITY RESUSCITATION SERVICES",
                "ACCIDENT & EMERGENCY AND RESUSCITATION SERVICES",
                "OUT PATIENT SERVICE",
                "CRITICAL CARE UNIT (HIGH CARE)",
                "COMBINED GENERAL MEDICAL/ SURGICAL/PAEDIATRIC WARDS",
                "GENERAL MEDICAL WARDS",
                "SURGICAL /ORTHOPAEDIC WARDS",
                "PAEDIATRIC CARE/ SPECIALTIES AND WARDS/ NEONATOLOGY",
                "OBSTETRICS AND GYNAECOLOGY",
                "PSYCHIATRIC SERVICES AND WARDS",
                "OPERATING THEATRE",
                "CENTRAL SUPPLIES AND STERILISATION DEPARTMENT (CSSD)",
                "PHARMACY",
                "LABORATORY",
                "ELISA--",
                "RADIOLOGY (MEDICAL IMAGING; X-RAY DEPARTMENT)",
                "DENTAL",
                "EYE CLINIC",
                "PHYSIOTHERAPY CARE",
                "DIETETICS",
                "FOOD SERVICE AND KITCHEN",
                "HOUSEKEEPING SERVICE",
                "LAUNDRY SERVICES",
                "MAINTENANCE SERVICES",
                "EQUIPMENT AND HEALTHCARE TECHNOLOGY",
                "HOSPITAL SUPPLIES",
                "OCCUPATIONAL THERAPY",
                "SPEECH THERAPY",
                "SOCIAL WORK",
            ]
        else:
            sections_to_process = self.sections

        for section in sections_to_process:
            normalized_section = self.normalize_section_name(section)

            # Get all questions that apply to this facility in this section
            applicable_questions = []

            for question_data in self.questions_data:
                if (question_data['section'] == section and
                    facility_index < len(question_data['applicability']) and
                    question_data['applicability'][facility_index]):
                    applicable_questions.append(question_data['question'])

            if applicable_questions:
                facility_config[normalized_section] = {
                    "showOnly": applicable_questions
                }
                print(f"  üìù {normalized_section}: {len(applicable_questions)} questions")

        return facility_config

    def sanitize_filename(self, facility_type):
        """Convert facility type to valid filename"""
        # Remove special characters and convert to lowercase
        filename = facility_type.lower()
        filename = filename.replace(' ', '').replace('(', '').replace(')', '')
        filename = filename.replace('-', '').replace('&', 'and').replace('/', '')
        filename = filename.replace(',', '').replace(':', '').replace(';', '')
        return filename + '.js'

    def generate_js_file_content(self, facility_type, config):
        """Generate the JavaScript file content for a facility filter"""
        sanitized_name = facility_type.replace(' ', '').replace('(', '').replace(')', '').replace('-', '').replace('/', '').replace(',', '').replace(':', '').replace(';', '').replace('&', 'and')

        content = f'''/**
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * Generated from: checklist-final.csv
 * Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
 * Facility Type: {facility_type}
 *
 * To regenerate this file, run: python src/config/generateFilters.py
 */

const {sanitized_name} = {{
'''

        for section_name, section_config in config.items():
            content += f'    "{section_name}": {{\n'
            content += f'        "showOnly": [\n'

            for question in section_config["showOnly"]:
                # Sanitize: collapse newlines, remove CRs, and escape backslashes/quotes
                sanitized = question.replace('\r\n', ' ').replace('\n', ' ').replace('\r', ' ').strip()
                sanitized = sanitized.replace('\\', '\\\\').replace('"', '\\"')
                content += f'            "{sanitized}",\n'

            content += f'        ]\n'
            content += f'    }},\n'

        content += f'''
}};

export default {sanitized_name};
'''

        return content

    def write_facility_filter_file(self, facility_type, config):
        """Write the filter configuration to a JavaScript file"""
        filename = self.sanitize_filename(facility_type)
        filepath = self.config_dir / filename

        content = self.generate_js_file_content(facility_type, config)

        with open(filepath, 'w', encoding='utf-8') as file:
            file.write(content)

        print(f"‚úÖ Generated: {filepath}")
        return filepath

    def generate_main_filters_file(self):
        """Generate the main facilityServiceFilters.js file with all imports"""
        imports = []
        mappings = []

        for facility_type in self.facility_types:
            sanitized_name = facility_type.replace(' ', '').replace('(', '').replace(')', '').replace('-', '').replace('/', '').replace(',', '').replace(':', '').replace(';', '').replace('&', 'and')
            filename = self.sanitize_filename(facility_type).replace('.js', '')

            imports.append(f"import {sanitized_name} from './{filename}.js';")
            mappings.append(f"    '{facility_type}': {sanitized_name},")
            mappings.append(f"    'Service {facility_type}': {sanitized_name},")

        content = f'''/**
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * Generated from: checklist-final.csv
 * Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
 *
 * This file imports all individual clinic filter files and combines them
 * To regenerate this file, run: python src/config/generateFilters.py
 */

{chr(10).join(imports)}

const facilityServiceFilters = {{
{chr(10).join(mappings)}
}};

export function shouldShowDataElementForService(dataElementName, selectedService) {{
    if (!selectedService || !facilityServiceFilters[selectedService]) {{
        return true; // Show all if no service selected or service not found
    }}

    const serviceFilters = facilityServiceFilters[selectedService];

    // Check if the data element should be shown for this service
    for (const section in serviceFilters) {{
        if (serviceFilters[section].showOnly && serviceFilters[section].showOnly.includes(dataElementName)) {{
            return true;
        }}
    }}

    return false; // Hide if not in showOnly lists
}}

export default facilityServiceFilters;
'''

        main_file_path = self.config_dir / "facilityServiceFilters.js"
        with open(main_file_path, 'w', encoding='utf-8') as file:
            file.write(content)

        print(f"‚úÖ Generated main file: {main_file_path}")
        return main_file_path

    def generate_facility_service_departments_file(self):
        """Generate the facilityServiceDepartments.js file based on actual sections from CSV"""
        print("üè¢ Generating facilityServiceDepartments.js...")

        # Get all unique sections (departments) from the CSV
        all_departments = []
        for section in self.sections:
            normalized_section = self.normalize_section_name(section)
            if normalized_section not in all_departments:
                all_departments.append(normalized_section)

        # Keep departments in the order they appear in the CSV file
        # (no sorting - preserve original order)

        # Build specialization to department mapping
        specialization_mapping = {}

        for i, facility_type in enumerate(self.facility_types):
            # Get sections that have questions for this facility type
            facility_departments = []

            # Special handling for Hospital to preserve CSV order
            if facility_type == 'Hospital':
                print(f"üè• Processing Hospital sections in CSV order...")
                # Hospital sections in CSV order
                hospital_sections_csv_order = [
                    "FACILITY GOVERNANCE AND MANAGEMENT",
                    "HUMAN RESOURCE MANAGEMENT",
                    "ADMINISTRATIVE SERVICES",
                    "FACILITY ENVIRONMENT",
                    "CUSTOMER CARE, RIGHTS AND SATISFACTION",
                    "SAFETY AND WASTE MANAGEMENT",
                    "INFECTION PREVENTION AND CONTROL",
                    "FACILITY RESUSCITATION SERVICES",
                    "ACCIDENT & EMERGENCY AND RESUSCITATION SERVICES",
                    "OUT PATIENT SERVICE",
                    "CRITICAL CARE UNIT (HIGH CARE)",
                    "COMBINED GENERAL MEDICAL/ SURGICAL/PAEDIATRIC WARDS",
                    "GENERAL MEDICAL WARDS",
                    "SURGICAL /ORTHOPAEDIC WARDS",
                    "PAEDIATRIC CARE/ SPECIALTIES AND WARDS/ NEONATOLOGY",
                    "OBSTETRICS AND GYNAECOLOGY",
                    "PSYCHIATRIC SERVICES AND WARDS",
                    "OPERATING THEATRE",
                    "CENTRAL SUPPLIES AND STERILISATION DEPARTMENT (CSSD)",
                    "PHARMACY",
                    "LABORATORY",
                    "ELISA--",
                    "RADIOLOGY (MEDICAL IMAGING; X-RAY DEPARTMENT)",
                    "DENTAL",
                    "EYE CLINIC",
                    "PHYSIOTHERAPY CARE",
                    "DIETETICS",
                    "FOOD SERVICE AND KITCHEN",
                    "HOUSEKEEPING SERVICE",
                    "LAUNDRY SERVICES",
                    "MAINTENANCE SERVICES",
                    "EQUIPMENT AND HEALTHCARE TECHNOLOGY",
                    "HOSPITAL SUPPLIES",
                    "OCCUPATIONAL THERAPY",
                    "SPEECH THERAPY",
                    "SOCIAL WORK",
                ]

                # Only include sections that actually have questions for Hospital
                for section in hospital_sections_csv_order:
                    has_questions = any(
                        question_data['section'] == section and
                        i < len(question_data['applicability']) and
                        question_data['applicability'][i]
                        for question_data in self.questions_data
                    )
                    if has_questions:
                        normalized_section = self.normalize_section_name(section)
                        facility_departments.append(normalized_section)
                        print(f"  ‚úÖ Added: {normalized_section}")
                    else:
                        print(f"  ‚ùå Skipped (no questions): {section}")

                print(f"üè• Hospital departments in order: {facility_departments[:5]}... (showing first 5)")
            else:
                # For other facility types, use the original logic
                for section in self.sections:
                    normalized_section = self.normalize_section_name(section)

                    # Check if this section has any questions for this facility
                    has_questions = any(
                        question_data['section'] == section and
                        i < len(question_data['applicability']) and
                        question_data['applicability'][i]
                        for question_data in self.questions_data
                    )

                    if has_questions:
                        facility_departments.append(normalized_section)

            # Keep departments in the order they appear in the CSV file
            # (no sorting - preserve original order)
            specialization_mapping[facility_type] = facility_departments

            print(f"  üè• {facility_type}: {len(facility_departments)} departments")

        # Generate the JavaScript content
        content = f'''/**
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * Generated from: checklist-final.csv
 * Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
 *
 * This file defines facility service departments based on actual sections
 * found in the CSV checklist configuration.
 * To regenerate this file, run: python src/config/generateFilters.py
 */

// All available facility service departments (sections from CSV)
export const ALL_FACILITY_DEPARTMENTS = [
'''

        # Add all departments (escape apostrophes for valid JS)
        for dept in all_departments:
            escaped_dept = dept.replace("'", "\\'")
            content += f"  '{escaped_dept}',\n"

        content += '''];

// Mapping of specializations to their available departments
export const SPECIALIZATION_DEPARTMENT_MAPPING = {
'''

        # Add specialization mappings (escape apostrophes for valid JS)
        for facility_type, departments in specialization_mapping.items():
            escaped_facility_type = facility_type.replace("'", "\\'")
            content += f"  '{escaped_facility_type}': [\n"
            for dept in departments:
                escaped_dept = dept.replace("'", "\\'")
                content += f"    '{escaped_dept}',\n"
            content += f"  ],\n\n"

        content += '''};

/**
 * Get departments available for a specific specialization
 * @param {string} specialization - The facility specialization
 * @returns {Array<string>} Array of department names
 */
export function getDepartmentsForSpecialization(specialization) {
  if (!specialization || !SPECIALIZATION_DEPARTMENT_MAPPING[specialization]) {
    return ALL_FACILITY_DEPARTMENTS;
  }
  return SPECIALIZATION_DEPARTMENT_MAPPING[specialization];
}

/**
 * Get statistics about departments for a specialization
 * @param {string} specialization - The facility specialization
 * @returns {Object} Statistics object with total and available counts
 */
export function getDepartmentStats(specialization) {
  const available = getDepartmentsForSpecialization(specialization);
  return {
    total: ALL_FACILITY_DEPARTMENTS.length,
    available: available.length,
    specialization: specialization
  };
}

export default {
  ALL_FACILITY_DEPARTMENTS,
  SPECIALIZATION_DEPARTMENT_MAPPING,
  getDepartmentsForSpecialization,
  getDepartmentStats
};
'''

        # Write the file
        departments_file_path = self.config_dir / "facilityServiceDepartments.js"
        with open(departments_file_path, 'w', encoding='utf-8') as file:
            file.write(content)

        print(f"‚úÖ Generated: {departments_file_path}")
        print(f"üìä Total departments: {len(all_departments)}")
        print(f"üè• Specializations: {len(specialization_mapping)}")

        return departments_file_path

    def generate_summary_report(self):
        """Generate a summary report of the generation process"""
        summary = {
            "generated_on": datetime.now().isoformat(),
            "source_file": self.csv_path,
            "facility_types": self.facility_types,
            "sections": [self.normalize_section_name(s) for s in self.sections],
            "statistics": {
                "total_facility_types": len(self.facility_types),
                "total_sections": len(self.sections),
                "total_questions": len(self.questions_data)
            }
        }

        # Add per-facility statistics
        summary["facility_statistics"] = {}
        for i, facility_type in enumerate(self.facility_types):
            applicable_count = sum(1 for q in self.questions_data
                                 if i < len(q['applicability']) and q['applicability'][i])
            summary["facility_statistics"][facility_type] = {
                "applicable_questions": applicable_count,
                "coverage_percentage": round((applicable_count / len(self.questions_data)) * 100, 1)
            }

        report_path = self.config_dir / "generation_report.json"
        with open(report_path, 'w', encoding='utf-8') as file:
            json.dump(summary, file, indent=2)

        print(f"üìä Generated report: {report_path}")
        return summary

    def run(self):
        """Main execution method"""
        print("üöÄ Starting Facility Filter Generation...")
        print("=" * 60)

        try:
            # Parse the CSV file
            self.parse_csv()

            print("\nüîß Generating individual filter files...")
            generated_files = []

            # Generate filter file for each facility type
            for i, facility_type in enumerate(self.facility_types):
                config = self.generate_facility_filter(i, facility_type)
                if config:  # Only generate if there are applicable questions
                    filepath = self.write_facility_filter_file(facility_type, config)
                    generated_files.append(filepath)
                else:
                    print(f"‚ö†Ô∏è  No applicable questions found for: {facility_type}")

            # Generate main filters file
            print(f"\nüîß Generating main facilityServiceFilters.js...")
            self.generate_main_filters_file()

            # Generate facility service departments file
            print(f"\nüè¢ Generating facilityServiceDepartments.js...")
            self.generate_facility_service_departments_file()

            # Generate summary report
            print(f"\nüìä Generating summary report...")
            self.generate_summary_report()

            print("\n" + "=" * 60)
            print("‚úÖ Generation Complete!")
            print(f"üìÅ Generated {len(generated_files)} facility filter files")
            print(f"üìÅ Generated main filter file: facilityServiceFilters.js")
            print(f"üìÅ Generated departments file: facilityServiceDepartments.js")
            print(f"üìä Total questions processed: {len(self.questions_data)}")
            print(f"üè• Facility types: {len(self.facility_types)}")
            print(f"üìã Sections: {len(self.sections)}")

            return True

        except Exception as e:
            print(f"‚ùå Error during generation: {str(e)}")
            return False

if __name__ == "__main__":
    generator = FacilityFilterGenerator()
    success = generator.run()

    if success:
        print("\nüéâ Filter generation completed successfully!")
        print("üí° You can now use the generated filter files in your application.")
    else:
        print("\nüí• Filter generation failed. Please check the error messages above.")
        exit(1)